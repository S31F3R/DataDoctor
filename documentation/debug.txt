# Query.py - Full buildTable with original logic restored, call added at end
def buildTable(table, data, buildHeader, dataDictionaryTable, intervals, lookupIds=None, labelsDict=None, databases=None, queryItems=None, deltaChecked=False, overlayChecked=False):
    if Config.debug:
        print("[DEBUG] buildTable: Starting with {} rows, {} headers".format(len(data), len(buildHeader)))
    table.clear()
    if not data:
        if Config.debug:
            print("[DEBUG] buildTable: No data to display.")
        return
    if isinstance(buildHeader, str):
        buildHeader = [h.strip() for h in buildHeader.split(',')]
    processedHeaders = []
    for i, h in enumerate(buildHeader):
        dataId = h.strip()
        intervalStr = intervals[i].upper()
        if intervalStr.startswith('INSTANT:'):
            intervalStr = 'INSTANT'
        database = databases[i] if databases and i < len(databases) else None
        dictRow = getDataDictionaryItem(dataDictionaryTable, lookupIds[i] if lookupIds else dataId)
        mrid = None
        if database and database.startswith('USBR-') and '-' in dataId:
            parts = dataId.rsplit('-', 1)
            dataId = parts[0]
            mrid = parts[1] if len(parts) > 1 else '0'
        if dictRow != -1:
            siteItem = dataDictionaryTable.item(dictRow, 1)
            baseLabel = siteItem.text().strip() if siteItem else dataId
            if database == 'USGS-NWIS':
                parts = dataId.split('-')
                if len(parts) == 3 and parts[0].isdigit() and (parts[1].isdigit() or (len(parts[1]) == 32 and parts[1].isalnum())) and parts[2].isdigit():
                    fullLabel = f"{parts[0]}-{parts[2]} \n{intervalStr}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: USGS in dict, header {i}: {fullLabel}")
                else:
                    fullLabel = f"{baseLabel} \n{intervalStr}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: USGS in dict but non-USGS format, header {i}: {fullLabel}")
            elif database == 'AQUARIUS' and labelsDict and dataId in labelsDict:
                apiFull = labelsDict[dataId]
                parts = apiFull.split('\n')
                label = parts[0].strip() if len(parts) >= 1 else dataId
                location = parts[1].strip() if len(parts) >= 2 else dataId
                fullLabel = f"{label} \n{location}"
                if Config.debug:
                    print(f"[DEBUG] buildTable: Aquarius in dict, header {i}: {fullLabel}")
            else:
                if mrid and mrid != '0':
                    fullLabel = f"{baseLabel} \n{dataId}-{mrid}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: USBR in dict with MRID, header {i}: {fullLabel}")
                else:
                    fullLabel = f"{baseLabel} \n{dataId}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: USBR in dict, header {i}: {fullLabel}")
        else:
            if database == 'USGS-NWIS':
                parts = dataId.split('-')
                if len(parts) == 3 and parts[0].isdigit() and (parts[1].isdigit() or (len(parts[1]) == 32 and parts[1].isalnum())) and parts[2].isdigit():
                    fullLabel = f"{parts[0]}-{parts[2]} \n{intervalStr}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: Parsed USGS header {i}: {fullLabel}")
                else:
                    fullLabel = f"{dataId} \n{intervalStr}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: USGS not in dict, header {i}: {fullLabel}")
            elif database == 'AQUARIUS' and labelsDict and dataId in labelsDict:
                apiFull = labelsDict[dataId]
                parts = apiFull.split('\n')
                label = parts[0].strip() if len(parts) >= 1 else dataId
                location = parts[1].strip() if len(parts) >= 2 else dataId
                fullLabel = f"{label} \n{location}"
                if Config.debug:
                    print(f"[DEBUG] buildTable: Aquarius not in dict, header {i}: {fullLabel}")
            else:
                if mrid and mrid != '0':
                    fullLabel = f"{dataId}-{mrid} \n{intervalStr}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: USBR not in dict with MRID, header {i}: {fullLabel}")
                else:
                    fullLabel = f"{dataId} \n{intervalStr}"
                    if Config.debug:
                        print(f"[DEBUG] buildTable: USBR not in dict, header {i}: {fullLabel}")
            processedHeaders.append(fullLabel)
    headers = processedHeaders
    skipDateCol = dataDictionaryTable is not None
    numCols = len(headers)
    numRows = len(data)
    if numRows > 10000:
        reply = QMessageBox.warning(None, "Large Dataset Warning",
                                   f"Query returned {numRows} rows, which may slow down the UI. Consider a smaller date range or coarser interval (e.g., HOUR instead of INSTANT:1). Continue?",
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if reply == QMessageBox.StandardButton.No:
            if Config.debug:
                print(f"[DEBUG] buildTable: User canceled due to large dataset ({numRows} rows)")
            return
    if Config.debug:
        print(f"[DEBUG] buildTable: Setting table to {numRows} rows, {numCols} columns")
    table.setRowCount(numRows)
    table.setColumnCount(numCols)
    table.setHorizontalHeaderLabels(headers)
    table.show()
    if dataDictionaryTable:
        timestamps = [row.split(',')[0].strip() for row in data]
        table.setVerticalHeaderLabels(timestamps)
        vHeader = table.verticalHeader()
        vHeader.setMinimumWidth(120)
        vHeader.setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
        vHeader.setVisible(True)
    else:
        table.verticalHeader().setVisible(False)
    font = table.font()
    metrics = QFontMetrics(font)
    columnWidths = []
    sampleRows = min(1000, numRows)
    if Config.debug:
        print(f"[DEBUG] buildTable: Sampling {sampleRows} rows for column widths")
    for c in range(numCols):
        cellValues = [row.split(',')[c+1].strip() if c+1 < len(row.split(',')) else "0.00" for row in data[:sampleRows]]
        nonEmptyValues = [val for val in cellValues if val]
        if nonEmptyValues:
            maxCellWidth = max(metrics.horizontalAdvance(val) for val in nonEmptyValues)
        else:
            maxCellWidth = metrics.horizontalAdvance("0.00")
            if Config.debug:
                print(f"[DEBUG] buildTable col {c}: No non-empty values, using fallback width {maxCellWidth}")
        headerLines = headers[c].split('\n')
        headerWidth = max(metrics.horizontalAdvance(line.strip()) for line in headerLines) if headerLines else 0
        if Config.debug:
            print(f"[DEBUG] buildTable col {c}: maxCellWidth={maxCellWidth}, headerWidth={headerWidth}")
        finalWidth = max(maxCellWidth, headerWidth)
        if headerWidth > maxCellWidth:
            paddingIncrease = headerWidth - maxCellWidth
            finalWidth = maxCellWidth + paddingIncrease + 10
        else:
            finalWidth += 20
        columnWidths.append(finalWidth)
    table.setUpdatesEnabled(False)
    if Config.debug:
        print("[DEBUG] buildTable: Disabled table updates for population")
    for rowIdx, rowStr in enumerate(data):
        rowData = rowStr.split(',')[1:] if skipDateCol else rowStr.split(',')
        for colIdx in range(min(numCols, len(rowData))):
            cellText = rowData[colIdx].strip() if colIdx < len(rowData) else ''
            item = QTableWidgetItem(cellText)
            item.setTextAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter)
            if not Config.rawData and cellText.strip():
                item.setText(Logic.valuePrecision(cellText))
            table.setItem(rowIdx, colIdx, item)
    table.setUpdatesEnabled(True)
    if Config.debug:
        print("[DEBUG] buildTable: Re-enabled table updates after population")
    table.horizontalHeader().sectionClicked.connect(lambda col: customSortTable(table, col, dataDictionaryTable))
    header = table.horizontalHeader()
    vHeader = table.verticalHeader()
    table.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
    table.setMinimumSize(0, 0)
    table.update()
    header.setStretchLastSection(False)
    if Config.debug:
        print("[DEBUG] buildTable: Set stretchLastSection=False to prevent last column expansion.")
    if dataDictionaryTable:
        maxTimeWidth = max(metrics.horizontalAdvance(ts) for ts in timestamps)
        vHeader.setMinimumWidth(max(120, maxTimeWidth) + 10)
    for c in range(numCols):
        table.setColumnWidth(c, columnWidths[c])
        if Config.debug:
            print(f"[DEBUG] buildTable: Set column {c} width to {columnWidths[c]}")
    rowHeight = metrics.height() + 10
    sampleItem = QTableWidgetItem("189.5140")
    sampleItem.setFont(font)
    sampleCellHeight = sampleItem.sizeHint().height()
    if sampleCellHeight <= 0:
        sampleCellHeight = metrics.height()
    adjustedRowHeight = max(rowHeight, sampleCellHeight + 2)
    if Config.debug:
        print(f"[DEBUG] buildTable: Sample cell height: {sampleCellHeight}, Adjusted row height: {adjustedRowHeight}")
    vHeader.setDefaultSectionSize(adjustedRowHeight)
    if Config.debug:
        print(f"[DEBUG] buildTable: Set default row height to {adjustedRowHeight}")
    header.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
    vHeader.setSectionResizeMode(QHeaderView.ResizeMode.Interactive)
    table.update()
    table.horizontalScrollBar().setValue(0)
    visibleWidth = table.columnWidth(1) if numCols > 1 else 0
    if Config.debug and numCols > 1:
        print(f"[DEBUG] buildTable: Custom resized {numCols} columns. Text width for col 1: {metrics.horizontalAdvance(headers[1])}, Visible width: {visibleWidth}, Row height: {adjustedRowHeight}")
    dataIds = buildHeader
    if Config.qaqcEnabled:
        qaqc(table, dataDictionaryTable, dataIds)
    else:
        for r in range(table.rowCount()):
            for c in range(table.columnCount()):
                item = table.item(r, c)
                if item:
                    item.setBackground(QColor(0, 0, 0, 0))
        if Config.debug:
            print("[DEBUG] buildTable: QAQC skipped, cleared cell backgrounds")

    # Post-QAQC delta/overlay if checked
    if deltaChecked or overlayChecked:
        from core.QueryUtils import processDeltaOverlay
        processDeltaOverlay(table, deltaChecked, overlayChecked, databases, queryItems, labelsDict, dataDictionaryTable, intervals, lookupIds)





from core import Logic, Config
from PyQt6.QtGui import QColor, QBrush
from PyQt6.QtCore import Qt
import numpy as np

def modifyTableForDeltaOverlay(table, deltaChecked, overlayChecked, databases, queryItems, labelsDict, dataDictionaryTable, intervals, lookupIds):
    if Config.debug:
        print("[DEBUG] modifyTableForDeltaOverlay: Starting with delta={}, overlay={}".format(deltaChecked, overlayChecked))

    numRows = table.rowCount()
    numCols = table.columnCount()

    # Extract current data as 2D array of floats/nan, and strings for display
    values = np.full((numRows, numCols), np.nan)
    displayTexts = [[''] * numCols for _ in range(numRows)]
    for r in range(numRows):
        for c in range(numCols):
            item = table.item(r, c)
            if item:
                displayTexts[r][c] = item.text()
                try:
                    values[r, c] = float(item.text()) if item.text() else np.nan
                except ValueError:
                    values[r, c] = np.nan

    # Original dataIds from lookupIds (or adjust if buildHeader available)
    dataIds = lookupIds if lookupIds else [table.horizontalHeaderItem(c).text().split('\n')[-1].strip() for c in range(numCols)]

    # Query infos
    queryInfos = [f"{item[0]}|{item[1]}|{item[2]}" for item in queryItems]

    # Determine pairs based on original numCols
    pairs = [(i, i+1) for i in range(0, numCols, 2)]

    if numCols % 2 == 1 and (deltaChecked or overlayChecked):
        print("[WARN] Odd number of query items; last item omitted from delta/overlay processing.")

    # Process pairs, add/remove columns in place
    addedCols = 0
    columnMetadata = []
    for pairIndex, (pIdx, sIdx) in enumerate(pairs):
        pIdx += addedCols  # Adjust for inserted/removed
        sIdx += addedCols
        primaryVals = values[:, pIdx]
        secondaryVals = values[:, sIdx]
        deltas = np.subtract(primaryVals, secondaryVals)
        deltas[~ (np.isfinite(primaryVals) & np.isfinite(secondaryVals))] = np.nan

        if overlayChecked:
            # Replace pIdx with combined, remove sIdx
            for r in range(numRows):
                item = table.item(r, pIdx)
                if item:
                    hasP = np.isfinite(primaryVals[r])
                    hasS = np.isfinite(secondaryVals[r])
                    d = deltas[r]
                    if hasP and hasS:
                        if d != 0:
                            item.setForeground(QColor(255, 0, 0))  # Red
                    elif not hasP and hasS:
                        item.setBackground(QColor(221, 160, 221))  # Light purple
                        item.setForeground(QColor(0, 0, 0))
                    elif hasP and not hasS:
                        item.setBackground(QColor(255, 182, 193))  # Light pink
                        item.setForeground(QColor(0, 0, 0))
                    # Set data for details
                    p = primaryVals[r]
                    s = secondaryVals[r]
                    pStr = Logic.valuePrecision(str(p)) if hasP and not Config.rawData else str(p) if hasP else ''
                    sStr = Logic.valuePrecision(str(s)) if hasS and not Config.rawData else str(s) if hasS else ''
                    dStr = Logic.valuePrecision(str(d)) if np.isfinite(d) and not Config.rawData else str(d) if np.isfinite(d) else ''
                    item.setData(Qt.UserRole, {
                        'primaryVal': pStr,
                        'secondaryVal': sStr,
                        'delta': dStr,
                        'dataId1': dataIds[pIdx],
                        'dataId2': dataIds[sIdx],
                        'db1': databases[pIdx],
                        'db2': databases[sIdx]
                    })
                    # Update text to display (use p if available, else s)
                    newText = pStr if hasP else sStr if hasS else ''
                    item.setText(newText)
            # Remove sIdx column
            table.removeColumn(sIdx)
            addedCols -= 1
            # Update header for overlay (primary's, already set)

            columnMetadata.append({
                'type': 'overlay',
                'dataIds': [dataIds[pIdx], dataIds[sIdx]],
                'dbs': [databases[pIdx], databases[sIdx]],
                'queryInfos': [queryInfos[pIdx], queryInfos[sIdx]],
                'pairIndex': pairIndex
            })

        else:
            columnMetadata.append({
                'type': 'normal',
                'dataIds': [dataIds[pIdx]],
                'dbs': [databases[pIdx]],
                'queryInfos': [queryInfos[pIdx]]
            })
            columnMetadata.append({
                'type': 'normal',
                'dataIds': [dataIds[sIdx]],
                'dbs': [databases[sIdx]],
                'queryInfos': [queryInfos[sIdx]]
            })

        if deltaChecked:
            # Add delta column after current pIdx (or original sIdx if no overlay)
            insertIdx = pIdx + 1
            table.insertColumn(insertIdx)
            addedCols += 1
            # Set header
            fullLabel = "Delta"
            table.setHorizontalHeaderItem(insertIdx, QTableWidgetItem(fullLabel))
            # Set cells
            for r in range(numRows):
                d = deltas[r]
                dStr = Logic.valuePrecision(str(d)) if np.isfinite(d) and not Config.rawData else str(d) if np.isfinite(d) else ''
                item = QTableWidgetItem(dStr)
                item.setTextAlignment(Qt.AlignmentFlag.AlignCenter | Qt.AlignmentFlag.AlignVCenter)
                if dStr:
                    try:
                        val = float(dStr)
                        if val > 0:
                            item.setForeground(QColor(255, 165, 0))  # Orange
                        elif val < 0:
                            item.setForeground(QColor(0, 0, 255))  # Blue
                    except ValueError:
                        pass
                table.setItem(r, insertIdx, item)

            columnMetadata.append({
                'type': 'delta',
                'dataIds': [dataIds[pIdx], dataIds[sIdx]],
                'dbs': [databases[pIdx], databases[sIdx]],
                'queryInfos': [queryInfos[pIdx], queryInfos[sIdx]],
                'pairIndex': pairIndex
            })

    # For odd last column if any
    if numCols % 2 == 1:
        columnMetadata.append({
            'type': 'normal',
            'dataIds': [dataIds[-1]],
            'dbs': [databases[-1]],
            'queryInfos': [queryInfos[-1]]
        })

    # Set columnMetadata on mainWindow
    widget = table
    mainWindow = None
    while widget is not None:
        if isinstance(widget, uiMain):
            mainWindow = widget
            break
        widget = widget.parent()
    if mainWindow:
        mainWindow.columnMetadata = columnMetadata
        if Config.debug:
            print("[DEBUG] modifyTableForDeltaOverlay: Set columnMetadata with {} entries".format(len(columnMetadata)))
    else:
        if Config.debug:
            print("[WARN] modifyTableForDeltaOverlay: Could not find uiMain for columnMetadata")

    # Recalculate widths for updated table
    font = table.font()
    metrics = QFontMetrics(font)
    sampleRows = min(1000, numRows)
    columnWidths = []
    for c in range(table.columnCount()):
        cellValues = [table.item(r, c).text() if table.item(r, c) else "0.00" for r in range(sampleRows)]
        nonEmptyValues = [val for val in cellValues if val]
        if nonEmptyValues:
            maxCellWidth = max(metrics.horizontalAdvance(val) for val in nonEmptyValues)
        else:
            maxCellWidth = metrics.horizontalAdvance("0.00")
        headerItem = table.horizontalHeaderItem(c)
        headerText = headerItem.text() if headerItem else ""
        headerLines = headerText.split('\n')
        headerWidth = max(metrics.horizontalAdvance(line.strip()) for line in headerLines) if headerLines else 0
        finalWidth = max(maxCellWidth, headerWidth)
        if headerWidth > maxCellWidth:
            paddingIncrease = headerWidth - maxCellWidth
            finalWidth = maxCellWidth + paddingIncrease + 10
        else:
            finalWidth += 20
        columnWidths.append(finalWidth)
    for c in range(table.columnCount()):
        table.setColumnWidth(c, columnWidths[c])
        if Config.debug:
            print(f"[DEBUG] modifyTableForDeltaOverlay: Set column {c} width to {columnWidths[c]}")